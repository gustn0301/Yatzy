<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yatzy Online 1v1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- Favicon -->
    <link rel="icon" href="https://img.icons8.com/color/48/dice.png" type="image/png">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            /* 네온사인 느낌의 배경 */
            background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
            background-size: 400% 400%;
            animation: gradient-animation 15s ease infinite;
        }
        @keyframes gradient-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .die { transition: all 0.2s ease-in-out; cursor: pointer; }
        .die.kept {
            border-color: #3b82f6;
            transform: scale(0.95);
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }
        .score-row.clickable:hover { background-color: #eff6ff; cursor: pointer; }
        .score-row.scored { color: #6b7280; background-color: #f3f4f6; }
        .potential-score { color: #3b82f6; font-weight: 500; }
        .leaderboard-item.current-player { background-color: #dbeafe; border-left: 4px solid #3b82f6; }
        .hidden { display: none; }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-6xl mx-auto bg-white rounded-2xl shadow-lg p-4 sm:p-6 md:p-8 relative">

        <!-- Matchmaking Screen -->
        <div id="setup-screen">
            <div class="flex justify-center items-center relative mb-4">
                <h1 class="text-4xl font-bold text-center text-gray-800">Yatzy Online</h1>
                <button id="show-rules-btn-setup" class="absolute right-0 top-0 bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg text-sm">게임 방법</button>
            </div>

            <!-- Main Menu -->
            <div id="main-menu">
                <p class="text-center text-xl text-gray-600 mt-4 mb-8">다른 플레이어와 1v1 대전을 즐겨보세요!</p>
                <div id="matchmaking-status" class="text-center my-4 h-6"></div> <!-- 상태 메시지 영역 -->
                <div class="flex flex-col sm:flex-row justify-center gap-4">
                    <button id="find-match-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 px-8 text-2xl rounded-lg shadow-md transition-transform transform hover:scale-105">랜덤 매칭 찾기</button>
                    <button id="friend-match-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-8 text-2xl rounded-lg shadow-md transition-transform transform hover:scale-105">친구와 대전하기</button>
                    <button id="start-ai-btn" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-4 px-8 text-2xl rounded-lg shadow-md transition-transform transform hover:scale-105">AI와 대전하기</button>
                    <button id="cancel-match-btn" class="hidden bg-gray-500 hover:bg-gray-600 text-white font-bold py-4 px-8 text-2xl rounded-lg shadow-md">매칭 취소</button>
                </div>
            </div>

            <!-- Friend Menu -->
            <div id="friend-menu" class="hidden">
                <p class="text-center text-xl text-gray-600 mt-4 mb-8">친구와 함께 플레이하세요.</p>
                <div id="friend-menu-status" class="text-center my-4 min-h-[2rem]"></div> <!-- 친구 메뉴 상태 -->
                
                <div id="friend-menu-buttons" class="flex flex-col sm:flex-row justify-center gap-4">
                    <button id="create-room-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 px-8 text-2xl rounded-lg shadow-md">방 만들기</button>
                </div>
    
                <div id="join-room-section" class="mt-8 border-t pt-6 text-center">
                    <h3 class="text-xl font-semibold text-gray-700 mb-4">방에 참가하기</h3>
                    <div class="flex justify-center items-center gap-2 max-w-sm mx-auto">
                        <input id="room-code-input" type="text" maxlength="6" placeholder="6자리 코드 입력" class="text-lg p-3 border rounded-lg w-full text-center tracking-widest font-mono">
                        <button id="join-room-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-lg">참가</button>
                    </div>
                </div>
                
                <div class="text-center mt-6">
                    <button id="back-to-main-menu-btn" class="text-gray-600 hover:text-gray-800">&larr; 뒤로가기</button>
                </div>
            </div>
            
            <!-- Lobby Screen (New) -->
            <div id="lobby-screen" class="hidden">
                <p class="text-center text-xl text-gray-600 mt-4 mb-2">친구 대기실</p>
                <div class="text-center my-4">
                    <span class="text-gray-700 text-lg">방 코드:</span>
                    <span id="lobby-room-code" class="block text-4xl font-bold text-blue-600 my-2 tracking-widest">...</span>
                    <span id="lobby-copy-code" class="text-blue-500 hover:text-blue-700 cursor-pointer text-sm">[코드 복사]</span>
                </div>
                
                <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">플레이어</h3>
                <div id="lobby-player-list" class="space-y-2 max-w-sm mx-auto min-h-[6rem]">
                    <!-- 플레이어 목록이 여기에 동적으로 추가됩니다 -->
                </div>
                
                <div id="lobby-status" class="text-center text-gray-600 my-4 h-6"></div> <!-- 로비 상태 메시지 -->
                
                <div id="lobby-host-controls" class="hidden text-center mt-6 space-x-4">
                    <button id="start-game-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 text-xl rounded-lg shadow-md disabled:opacity-50" disabled>게임 시작 (2/2)</button>
                    <button id="cancel-room-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-8 text-xl rounded-lg shadow-md">방 해산</button>
                </div>
                <div id="lobby-guest-controls" class="hidden text-center mt-6">
                    <button id="leave-lobby-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-8 text-xl rounded-lg shadow-md">로비로 나가기</button>
                </div>
            </div>

             <div class="text-center mt-4 text-xs text-gray-500">
                <p>내 플레이어 ID: <span id="player-id"></span></p>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="hidden">
            <header class="text-center mb-6 relative">
                 <div class="flex justify-center items-center relative mb-2">
                    <h1 class="text-4xl font-bold text-center text-gray-800">Yatzy Online</h1>
                    <button id="show-rules-btn-game" class="absolute right-0 top-0 bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg text-sm">게임 방법</button>
                </div>
                <p id="turn-indicator" class="mt-2 text-2xl font-bold text-blue-600"></p>
                <p id="message-area" class="mt-1 text-lg text-gray-600 h-6"></p> <!-- 메시지 영역 높이 고정 -->
                <div id="dice-container" class="flex justify-center items-center gap-2 sm:gap-4 my-6 h-24"></div>
                <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
                    <button id="roll-button" class="w-full sm:w-auto bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-lg shadow-md">
                        주사위 굴리기
                    </button>
                    <p class="text-xl font-medium text-gray-700">남은 횟수: <span id="rolls-left" class="font-bold text-blue-600">3</span></p>
                </div>
            </header>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 border-t-2 border-gray-200 pt-6">
                <div class="md:col-span-2 bg-gray-50 rounded-lg p-4">
                    <h2 id="scoreboard-title" class="text-2xl font-bold text-center mb-4 text-gray-700"></h2>
                    <table class="w-full text-sm sm:text-base">
                        <tbody id="upper-section-body"></tbody>
                        <tbody class="border-t-2 border-gray-300">
                            <tr><td class="font-bold">상단 합계</td><td id="upper-subtotal" class="text-right font-bold">0</td></tr>
                            <tr><td>보너스 (+35)</td><td id="bonus" class="text-right font-bold">0</td></tr>
                            <tr class="bg-gray-200"><td class="font-bold">상단 총점</td><td id="upper-total" class="text-right font-bold">0</td></tr>
                        </tbody>
                        <tbody id="lower-section-body" class="border-t-2 border-gray-300"></tbody>
                        <tfoot class="border-t-2 border-gray-300">
                            <tr class="bg-blue-100"><td class="text-xl font-bold">총점</td><td id="grand-total" class="text-xl text-right font-bold">0</td></tr>
                        </tfoot>
                    </table>
                </div>
                <div class="md:col-span-1 bg-gray-50 rounded-lg p-4">
                    <h2 class="text-2xl font-bold text-center mb-4 text-gray-700">현재 점수</h2>
                    <div id="leaderboard" class="space-y-2"></div>
                </div>
            </div>
            <div class="text-center mt-8">
                <button id="leave-game-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-sm">
                    게임 나가기
                </button>
            </div>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-40">
        <div class="bg-white rounded-lg p-8 text-center shadow-2xl">
            <h2 class="text-3xl font-bold mb-4">게임 종료!</h2>
            <div id="final-leaderboard" class="text-lg mb-6 space-y-2"></div>
            <p id="winner-message" class="text-2xl font-bold text-blue-600 mb-6"></p>
            <button id="modal-new-game-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg">
                새 게임 시작하기
            </button>
        </div>
    </div>
    
    <!-- Game Rules Modal -->
    <div id="game-rules-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-white rounded-lg p-6 sm:p-8 text-left shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-bold">Yatzy 게임 방법</h2>
                <button id="close-rules-btn" class="text-gray-500 hover:text-gray-800 text-3xl font-bold">&times;</button>
            </div>
            <div class="space-y-4 text-gray-700">
                <p class="font-bold text-lg">게임 목표:</p>
                <p>총 13라운드를 진행하여 13개의 점수 조합을 모두 채우고, 가장 높은 총점을 얻는 것이 목표입니다.</p>

                <p class="font-bold text-lg">게임 진행:</p>
                <ul class="list-disc list-inside space-y-2 pl-4">
                    <li><strong>주사위 굴리기:</strong> 자신의 턴에 최대 3번까지 주사위를 굴릴 수 있습니다.</li>
                    <li><strong>주사위 유지:</strong> 굴린 후, 원하는 주사위를 클릭하여 '유지'할 수 있습니다. 유지된 주사위는 다음 굴리기에서 바뀌지 않습니다.</li>
                    <li><strong>점수 기록:</strong> 3번을 모두 굴렸거나 중간에 멈추고 싶다면, 반드시 13개의 점수 항목 중 하나를 선택하여 점수를 기록해야 합니다. (해당 조합이 나오지 않아도 0점을 기록해야 합니다.)</li>
                </ul>

                <p class="font-bold text-lg">점수판:</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <h3 class="font-semibold text-xl mb-2">상단 (Upper Section)</h3>
                        <ul class="list-disc list-inside space-y-1 pl-4">
                            <li><strong>Aces (1):</strong> 1이 나온 주사위의 합</li>
                            <li><strong>Twos (2):</strong> 2가 나온 주사위의 합</li>
                            <li><strong>Threes (3):</strong> 3이 나온 주사위의 합</li>
                            <li><strong>Fours (4):</strong> 4가 나온 주사위의 합</li>
                            <li><strong>Fives (5):</strong> 5가 나온 주사위의 합</li>
                            <li><strong>Sixes (6):</strong> 6이 나온 주사위의 합</li>
                            <li><strong>보너스:</strong> 상단 6개 항목의 합(상단 합계)이 63점 이상일 경우, <strong>보너스 35점</strong>을 추가로 얻습니다.</li>
                        </ul>
                    </div>
                    <div>
                        <h3 class="font-semibold text-xl mb-2">하단 (Lower Section)</h3>
                        <ul class="list-disc list-inside space-y-1 pl-4">
                            <li><strong>3 of a Kind:</strong> 동일한 주사위 3개 이상. (모든 주사위 눈의 합)</li>
                            <li><strong>4 of a Kind:</strong> 동일한 주사위 4개 이상. (모든 주사위 눈의 합)</li>
                            <li><strong>Full House:</strong> 3개 + 2개 (예: 4,4,4,2,2). (고정 25점)</li>
                            <li><strong>Small Straight:</strong> 4개의 연속된 숫자 (1-2-3-4, 2-3-4-5, 3-4-5-6). (고정 30점)</li>
                            <li><strong>Large Straight:</strong> 5개의 연속된 숫자 (1-2-3-4-5, 2-3-4-5-6). (고정 40점)</li>
                            <li><strong>Yatzy:</strong> 5개 모두 동일한 숫자. (고정 50점)</li>
                            <li><strong>Chance:</strong> 조건 없음. (모든 주사위 눈의 합)</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="text-right mt-6">
                <button id="close-rules-btn-bottom" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg">
                    닫기
                </button>
            </div>
        </div>
    </div>
    
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, collection, query, where, getDocs, deleteDoc, onSnapshot, updateDoc, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    
    // This is a public configuration.
    const firebaseConfig = {
      apiKey: "AIzaSyDkQFPUAPnkMjbmLfNCaThbWQ0yzzrT7mU",
      authDomain: "yatzy-online-3a321.firebaseapp.com",
      projectId: "yatzy-online-3a321",
      storageBucket: "yatzy-online-3a321.appspot.com",
      messagingSenderId: "1085827487793",
      appId: "1:1085827487793:web:2e40bb73e20dfba34b5d10"
    };
    
    try {
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- DOM Elements ---
        const setupScreen = document.getElementById('setup-screen');
        const gameScreen = document.getElementById('game-screen');
        const mainMenu = document.getElementById('main-menu');
        const friendMenu = document.getElementById('friend-menu');
        const lobbyScreen = document.getElementById('lobby-screen');
        
        const findMatchBtn = document.getElementById('find-match-btn');
        const friendMatchBtn = document.getElementById('friend-match-btn');
        const startAiBtn = document.getElementById('start-ai-btn');
        const cancelMatchBtn = document.getElementById('cancel-match-btn');
        const matchmakingStatus = document.getElementById('matchmaking-status');
        
        // Friend Menu
        const friendMenuStatus = document.getElementById('friend-menu-status');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomSection = document.getElementById('join-room-section');
        const roomCodeInput = document.getElementById('room-code-input');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const backToMainMenuBtn = document.getElementById('back-to-main-menu-btn');

        // Lobby (New)
        const lobbyRoomCode = document.getElementById('lobby-room-code');
        const lobbyCopyCode = document.getElementById('lobby-copy-code');
        const lobbyPlayerList = document.getElementById('lobby-player-list');
        const lobbyStatus = document.getElementById('lobby-status');
        const lobbyHostControls = document.getElementById('lobby-host-controls');
        const lobbyGuestControls = document.getElementById('lobby-guest-controls');
        const startGameBtn = document.getElementById('start-game-btn');
        const cancelRoomBtn = document.getElementById('cancel-room-btn');
        const leaveLobbyBtn = document.getElementById('leave-lobby-btn');


        const diceContainer = document.getElementById('dice-container');
        const rollButton = document.getElementById('roll-button');
        const leaderboard = document.getElementById('leaderboard');
        const gameOverModal = document.getElementById('game-over-modal');
        const playerIdEl = document.getElementById('player-id');
        const leaveGameButton = document.getElementById('leave-game-button');
        const modalNewGameButton = document.getElementById('modal-new-game-button');
        
        // Rules Modal Elements
        const showRulesBtnSetup = document.getElementById('show-rules-btn-setup');
        const showRulesBtnGame = document.getElementById('show-rules-btn-game');
        const gameRulesModal = document.getElementById('game-rules-modal');
        const closeRulesBtn = document.getElementById('close-rules-btn');
        const closeRulesBtnBottom = document.getElementById('close-rules-btn-bottom');

        // --- Game State ---
        let state = {};
        let userId, myPlayerIndex, gameId, hostId;
        let gameMode = null; // 'online-random', 'online-private', or 'ai'
        let gameUnsubscribe = null, waitingUnsubscribe = null;
        let aiTurnTimeout = null; // AI 턴 *시작* 타이머 (잠금 역할)
        let scoreMessageTimeout = null; // 점수 메시지 타이머

        const SCORE_CATEGORIES = {
            upper: { aces: '1 (Aces)', twos: '2 (Twos)', threes: '3 (Threes)', fours: '4 (Fours)', fives: '5 (Fives)', sixes: '6 (Sixes)' },
            lower: { threeOfAKind: '3 of a Kind', fourOfAKind: '4 of a Kind', fullHouse: 'Full House', smallStraight: 'Small Straight', largeStraight: 'Large Straight', yatzy: 'Yatzy', chance: 'Chance' }
        };
        
        // --- Authentication ---
        onAuthStateChanged(auth, user => {
            if (user) {
                userId = user.uid;
                playerIdEl.textContent = userId.substring(0, 8);
                findMatchBtn.disabled = false;
                startAiBtn.disabled = false;
                friendMatchBtn.disabled = false;
            } else {
                findMatchBtn.disabled = true;
                startAiBtn.disabled = true;
                friendMatchBtn.disabled = true;
            }
        });
        await signInAnonymously(auth);

        // --- UI Logic ---
        function init() {
            if (gameUnsubscribe) { gameUnsubscribe(); gameUnsubscribe = null; }
            if (waitingUnsubscribe) { waitingUnsubscribe(); waitingUnsubscribe = null; }
            if (aiTurnTimeout) { clearTimeout(aiTurnTimeout); aiTurnTimeout = null; }
            if (scoreMessageTimeout) { clearTimeout(scoreMessageTimeout); scoreMessageTimeout = null; }
            
            gameScreen.classList.add('hidden');
            setupScreen.classList.remove('hidden');
            gameOverModal.classList.add('hidden');
            gameRulesModal.classList.add('hidden');
            
            mainMenu.classList.remove('hidden');
            friendMenu.classList.add('hidden');
            lobbyScreen.classList.add('hidden');
            
            findMatchBtn.classList.remove('hidden');
            friendMatchBtn.classList.remove('hidden');
            startAiBtn.classList.remove('hidden');
            cancelMatchBtn.classList.add('hidden');
            cancelMatchBtn.textContent = '매칭 취소';

            matchmakingStatus.textContent = '';
            friendMenuStatus.textContent = '';
            state = {};
            gameId = null;
            hostId = null;
            myPlayerIndex = null;
            gameMode = null;
        }
        
        function showFriendMenu() {
            mainMenu.classList.add('hidden');
            friendMenu.classList.remove('hidden');
            
            friendMenuStatus.textContent = '';
            roomCodeInput.value = '';
            roomCodeInput.disabled = false;
            joinRoomBtn.disabled = false;
        }

        async function findMatch() {
            gameMode = 'online-random';
            findMatchBtn.classList.add('hidden');
            friendMatchBtn.classList.add('hidden');
            startAiBtn.classList.add('hidden');
            cancelMatchBtn.classList.remove('hidden');
            matchmakingStatus.textContent = '상대를 찾고 있습니다...';
            
            const waitingRef = collection(db, "waitingRoom");
            const q = query(waitingRef, where("playerId", "!=", userId));
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
                const opponentDoc = querySnapshot.docs[0];
                const opponentId = opponentDoc.id; 
                const newGameRef = doc(collection(db, "games"));
                gameId = newGameRef.id;

                const initialGameState = createInitialState(opponentId, userId);
                hostId = opponentId; // The one waiting is the host

                try {
                    await runTransaction(db, async (transaction) => {
                        transaction.delete(doc(db, "waitingRoom", opponentId));
                        transaction.set(newGameRef, initialGameState);
                    });
                    subscribeToGame(gameId);
                } catch (e) {
                    console.error("Transaction failed: ", e);
                    init();
                }

            } else {
                const myWaitingRef = doc(db, "waitingRoom", userId);
                await setDoc(myWaitingRef, { playerId: userId, timestamp: serverTimestamp() });

                waitingUnsubscribe = onSnapshot(myWaitingRef, (doc) => {
                    if (!doc.exists()) { // Matched by someone else
                         findGameAndJoin();
                    }
                });
            }
        }
        
        async function cancelMatch() { // For random matching
            if (waitingUnsubscribe) {
                waitingUnsubscribe();
                waitingUnsubscribe = null;
            }
            try {
                if (gameMode === 'online-random') {
                    const myWaitingRef = doc(db, "waitingRoom", userId);
                    await deleteDoc(myWaitingRef);
                }
            } catch (error) {
                console.error("Error removing document from waiting room:", error);
            }
            init();
        }

        // --- Friend Room Logic ---
        async function createRoom() {
            gameMode = 'online-private';
            const roomCode = Math.floor(100000 + Math.random() * 900000).toString();
            gameId = roomCode;
            hostId = userId; // I am the host
            
            friendMenu.classList.add('hidden');
            lobbyScreen.classList.remove('hidden');
            lobbyStatus.innerHTML = `방을 만드는 중...`;
            
            const gameDocRef = doc(db, "games", roomCode);
            
            try {
                const docSnap = await getDoc(gameDocRef);
                if (docSnap.exists()) {
                    friendMenu.classList.remove('hidden');
                    lobbyScreen.classList.add('hidden');
                    friendMenuStatus.textContent = '오류: 방 생성 실패. 다시 시도하세요.';
                    return;
                }
                
                // Create a 'lobby' game state
                const scoreSheet = () => {
                    const sheet = {};
                    Object.keys({...SCORE_CATEGORIES.upper, ...SCORE_CATEGORIES.lower}).forEach(id => { sheet[id] = null; });
                    return sheet;
                };
                const initialGameState = {
                    players: [userId], // Host is Player 1
                    playerNames: { [userId]: 'Player 1' },
                    hostId: userId,
                    dice: [1, 2, 3, 4, 5], kept: [false, false, false, false, false],
                    rollsLeft: 3, round: 1, currentPlayer: 0,
                    scores: [scoreSheet(), scoreSheet()],
                    isTurnStarted: false, 
                    status: 'lobby', // Host waits in lobby
                    createdAt: serverTimestamp(),
                    message: `친구를 기다리는 중...`
                };
                
                await setDoc(gameDocRef, initialGameState);
                
                subscribeToGame(roomCode); // Host starts listening
                
            } catch (e) {
                console.error("Error creating room: ", e);
                friendMenu.classList.remove('hidden');
                lobbyScreen.classList.add('hidden');
                friendMenuStatus.textContent = `오류: ${e.message}`;
                showFriendMenu();
            }
        }
        
        async function joinRoomWithCode() {
            gameMode = 'online-private';
            const roomCode = roomCodeInput.value.trim();
            if (roomCode.length !== 6 || !/^\d{6}$/.test(roomCode)) {
                friendMenuStatus.textContent = '6자리 숫자로 된 코드를 입력하세요.';
                return;
            }
            
            joinRoomBtn.disabled = true;
            roomCodeInput.disabled = true;
            friendMenuStatus.textContent = `"${roomCode}" 방에 참가하는 중...`;
            
            const gameDocRef = doc(db, "games", roomCode);
            gameId = roomCode;
            
            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameDocRef);
                    if (!gameDoc.exists()) {
                        throw new Error("방을 찾을 수 없습니다.");
                    }
                    
                    const gameData = gameDoc.data();
                    hostId = gameData.hostId;
                    
                    if (gameData.status !== 'lobby') {
                        throw new Error("방이 꽉 찼거나 이미 시작되었습니다.");
                    }
                    if (gameData.players.length >= 2) {
                        throw new Error("방이 꽉 찼습니다.");
                    }
                    if (gameData.players.includes(userId)) {
                        console.warn("Player already in room.");
                    } else {
                        // Join as Player 2
                        transaction.update(gameDocRef, {
                            players: [...gameData.players, userId],
                            playerNames: { ...gameData.playerNames, [userId]: 'Player 2' },
                            message: `Player 2 (${userId.substring(0, 4)}...)님이 입장했습니다.`
                        });
                    }
                });
                
                // Transaction successful, subscribe to the game
                friendMenu.classList.add('hidden');
                lobbyScreen.classList.remove('hidden');
                subscribeToGame(roomCode); 
                
            } catch (e) {
                console.error("Join room failed: ", e);
                friendMenuStatus.textContent = `참가 실패: ${e.message}`;
                joinRoomBtn.disabled = false;
                roomCodeInput.disabled = false;
            }
        }
        
        async function cancelRoom() { // For private room host
            if (gameId) {
                if (gameUnsubscribe) { gameUnsubscribe(); gameUnsubscribe = null; }
                try {
                    // Delete the room
                    await deleteDoc(doc(db, "games", gameId)); 
                } catch (error) { 
                    console.error("Error deleting room:", error);
                }
            }
            init(); // Go back to main menu
        }

        async function leaveLobby() { // For private room guest
            if (gameId) {
                if (gameUnsubscribe) { gameUnsubscribe(); gameUnsubscribe = null; }
                try {
                    // Just remove myself from the player list
                    await runTransaction(db, async (transaction) => {
                        const gameDoc = await transaction.get(doc(db, "games", gameId));
                        if (!gameDoc.exists()) return;
                        const gameData = gameDoc.data();
                        const newPlayers = gameData.players.filter(p => p !== userId);
                        const newPlayerNames = { ...gameData.playerNames };
                        delete newPlayerNames[userId];
                        transaction.update(doc(db, "games", gameId), {
                            players: newPlayers,
                            playerNames: newPlayerNames,
                            message: `Player ${myPlayerIndex + 1}님이 나갔습니다.`
                        });
                    });
                } catch (error) {
                    console.error("Error leaving lobby:", error);
                }
            }
            init(); // Go back to main menu
        }

        async function kickPlayer(guestId) {
            if (userId !== hostId || !gameId) return; // Only host can kick
            
            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(doc(db, "games", gameId));
                    if (!gameDoc.exists()) return;
                    const gameData = gameDoc.data();
                    
                    const guestPlayerIndex = gameData.players.indexOf(guestId);
                    if (guestPlayerIndex === -1) return; // Player already left

                    const newPlayers = gameData.players.filter(p => p !== guestId);
                    const newPlayerNames = { ...gameData.playerNames };
                    delete newPlayerNames[guestId];
                    
                    transaction.update(doc(db, "games", gameId), {
                        players: newPlayers,
                        playerNames: newPlayerNames,
                        message: `Player ${guestPlayerIndex + 1}님을 추방했습니다.`
                    });
                });
            } catch (error) {
                console.error("Error kicking player:", error);
                lobbyStatus.textContent = "추방 실패: " + error.message;
            }
        }
        
        async function startGame() {
            if (userId !== hostId || !gameId) return; // Only host can start
            
            try {
                await updateDoc(doc(db, "games", gameId), {
                    status: 'active',
                    message: 'Player 1의 턴입니다.'
                });
                // The onSnapshot listener will handle moving to the game-screen
            } catch (error) {
                console.error("Error starting game:", error);
                lobbyStatus.textContent = "게임 시작 실패: " + error.message;
            }
        }

        // --- AI Game Logic ---
        function startAiGame() {
            gameMode = 'ai';
            myPlayerIndex = 0; // Player 1 is human
            
            const scoreSheet = () => {
                const sheet = {};
                Object.keys({...SCORE_CATEGORIES.upper, ...SCORE_CATEGORIES.lower}).forEach(id => { sheet[id] = null; });
                return sheet;
            };

            state = {
                players: [userId, 'AI'],
                playerNames: { [userId]: 'Player 1', 'AI': 'AI' },
                hostId: userId,
                dice: [1, 2, 3, 4, 5], kept: [false, false, false, false, false],
                rollsLeft: 3, round: 1, currentPlayer: 0, // Player 1 (human) starts
                scores: [scoreSheet(), scoreSheet()],
                isTurnStarted: false, status: 'active',
                message: "당신의 턴입니다."
            };
            
            setupScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            updateGameUI();
        }

        /**
         * AI 모드에서 로컬 게임 상태를 업데이트합니다.
         */
        function updateGameState(newState) {
            state = { ...state, ...newState };
            updateGameUI();
            
            if (state.status === 'finished') {
                endGame(true);
            }
        }
        
        // --- Common Game Functions ---

        function createInitialState(player1Id, player2Id) {
             const scoreSheet = () => {
                const sheet = {};
                Object.keys({...SCORE_CATEGORIES.upper, ...SCORE_CATEGORIES.lower}).forEach(id => { sheet[id] = null; });
                return sheet;
            };
            return {
                players: [player1Id, player2Id],
                playerNames: { [player1Id]: 'Player 1', [player2Id]: 'Player 2' },
                hostId: player1Id, // The one waiting is host
                dice: [1, 2, 3, 4, 5], kept: [false, false, false, false, false],
                rollsLeft: 3, round: 1, currentPlayer: 0, 
                scores: [scoreSheet(), scoreSheet()],
                isTurnStarted: false, status: 'active', createdAt: serverTimestamp(),
                message: `Player 1의 턴입니다.`
            };
        }
        
        async function findGameAndJoin() { // For random matchers
            if (waitingUnsubscribe) { waitingUnsubscribe(); waitingUnsubscribe = null; }
            const gamesRef = collection(db, "games");
            // Find a game I was just added to (as player 2)
            const q = query(gamesRef, where("players", "array-contains", userId), where("status", "==", "active"));
            const snapshot = await getDocs(q);
            if(!snapshot.empty) {
                const gameDoc = snapshot.docs.find(d => d.data().players[1] === userId);
                if (gameDoc) {
                    subscribeToGame(gameDoc.id);
                }
            }
        }

        function subscribeToGame(newGameId) {
            if (waitingUnsubscribe) { waitingUnsubscribe(); waitingUnsubscribe = null; }
            gameId = newGameId;
            hostId = state.hostId; // Set hostId from state if joining
            
            if(gameUnsubscribe) { gameUnsubscribe(); gameUnsubscribe = null; }
            
            gameUnsubscribe = onSnapshot(doc(db, "games", gameId), (doc) => {
                if (doc.exists()) {
                    const oldStatus = state.status;
                    state = doc.data();
                    myPlayerIndex = state.players.indexOf(userId);
                    hostId = state.hostId; // Keep hostId updated
                    
                    // Kicked or Left
                    if (myPlayerIndex === -1 && (state.status === 'lobby' || state.status === 'active')) {
                        alert("방에서 추방되었거나 호스트가 방을 나갔습니다.");
                        init();
                        return;
                    }

                    if(state.status === 'finished') {
                        lobbyScreen.classList.add('hidden'); // Hide lobby if game finishes
                        endGame(true);
                    } else if (state.status === 'lobby') {
                        setupScreen.classList.remove('hidden');
                        friendMenu.classList.add('hidden');
                        lobbyScreen.classList.remove('hidden');
                        gameScreen.classList.add('hidden');
                        updateLobbyUI();
                    } else if (state.status === 'active') {
                        setupScreen.classList.add('hidden');
                        lobbyScreen.classList.add('hidden');
                        gameScreen.classList.remove('hidden');
                        updateGameUI();
                    }
                } else {
                    // Game doc was deleted (host canceled, or opponent left)
                    if (gameMode === 'online-private') {
                        alert("호스트가 방을 취소했습니다. 로비로 돌아갑니다.");
                    } else if (gameMode === 'online-random') {
                        alert("상대가 게임을 떠났거나 게임이 종료되었습니다. 로비로 돌아갑니다.");
                    }
                    init();
                }
            });
        }
        
        function updateLobbyUI() {
            if (!state || !state.players) return;
            
            lobbyRoomCode.textContent = gameId;
            lobbyPlayerList.innerHTML = '';
            
            state.players.forEach((pId, i) => {
                let playerName = `Player ${i + 1}`;
                let isHost = (pId === state.hostId);
                let isMe = (pId === userId);
                
                let playerHTML = `
                    <div class="flex justify-between items-center p-3 bg-gray-100 rounded-lg">
                        <span class="font-bold text-lg">${playerName} ${isHost ? '(Host)' : ''} ${isMe ? '(나)' : ''}</span>
                        ${(userId === hostId && !isMe) ? 
                            `<button data-kick-id="${pId}" class="kick-btn bg-red-500 hover:bg-red-600 text-white text-sm font-bold py-1 px-3 rounded">추방</button>` : 
                            ''}
                    </div>
                `;
                lobbyPlayerList.innerHTML += playerHTML;
            });
            
            if (userId === hostId) {
                // Host View
                lobbyHostControls.classList.remove('hidden');
                lobbyGuestControls.classList.add('hidden');
                
                if (state.players.length === 2) {
                    startGameBtn.disabled = false;
                    lobbyStatus.textContent = "플레이어가 모두 모였습니다. 게임을 시작하세요!";
                } else {
                    startGameBtn.disabled = true;
                    lobbyStatus.textContent = "친구가 입장하기를 기다리는 중...";
                }
            } else {
                // Guest View
                lobbyHostControls.classList.add('hidden');
                lobbyGuestControls.classList.remove('hidden');
                lobbyStatus.textContent = "호스트가 게임을 시작하기를 기다리는 중...";
            }
        }

        function updateGameUI() {
            if (!state || !state.players) return;
            
            // If I'm a guest who just joined, myPlayerIndex might be -1 on first render
            if (myPlayerIndex === -1) myPlayerIndex = state.players.indexOf(userId);
            if (myPlayerIndex === -1) return; // Still not in players list, wait for next snapshot
            
            document.getElementById('dice-container').innerHTML = state.dice.map((val, i) => getDieHTML(val, i, state.kept[i])).join('');
            
            const isMyTurn = state.currentPlayer === myPlayerIndex;
            document.getElementById('rolls-left').textContent = state.rollsLeft;
            
            let turnName = "대기 중...";
            if (state.status === 'active') {
                 turnName = isMyTurn ? '내 턴' : (gameMode.startsWith('online') ? '상대 턴' : 'AI 턴');
            }
            
            document.getElementById('turn-indicator').textContent = `라운드 ${state.round}/13 • ${turnName}`;

            let titlePlayerName = '점수판';
            if (state.status === 'active') {
                titlePlayerName = isMyTurn ? '내' : (gameMode.startsWith('online') ? '상대' : 'AI');
                titlePlayerName += ` 점수판 (Player ${state.currentPlayer + 1})`;
            }
            document.getElementById('scoreboard-title').textContent = titlePlayerName;
            
            // 점수 기록 메시지가 아닐 때만 일반 메시지 표시
            if (!scoreMessageTimeout) {
                document.getElementById('message-area').textContent = state.message || '';
            }

            rollButton.disabled = !isMyTurn || state.rollsLeft === 0 || state.status !== 'active' || (state.isTurnStarted === false && state.rollsLeft < 3);
            rollButton.classList.toggle('opacity-50', rollButton.disabled);

            updateScoresheet();
            updateLeaderboard();
        }

        function updateScoresheet() {
            const displayPlayerIndex = (state.status === 'lobby') ? 0 : state.currentPlayer;
            if (!state.scores || !state.scores[displayPlayerIndex]) return; // Guard clause
            
            const playerScores = state.scores[displayPlayerIndex];
            const potential = state.isTurnStarted ? calculateScores(state.dice) : {};

            let upperSubtotal = 0;
            document.querySelectorAll('#game-screen .score-row').forEach(row => {
                const id = row.dataset.id;
                const scoreCell = row.querySelector('.score');
                if (playerScores[id] !== null) {
                    scoreCell.textContent = playerScores[id];
                    scoreCell.classList.remove('potential-score');
                    row.classList.add('scored', 'opacity-70');
                    row.classList.remove('clickable');
                } else {
                    scoreCell.textContent = (state.isTurnStarted && state.currentPlayer === myPlayerIndex) ? potential[id] : '';
                    scoreCell.classList.toggle('potential-score', state.isTurnStarted && state.currentPlayer === myPlayerIndex);
                    row.classList.remove('scored', 'opacity-70');
                    row.classList.toggle('clickable', state.isTurnStarted && state.currentPlayer === myPlayerIndex && state.status === 'active');
                }
                 if (SCORE_CATEGORIES.upper[id] && playerScores[id] !== null) {
                    upperSubtotal += playerScores[id];
                }
            });
            
            const bonus = upperSubtotal >= 63 ? 35 : 0;
            document.getElementById('upper-subtotal').textContent = upperSubtotal;
            document.getElementById('bonus').textContent = bonus;
            document.getElementById('upper-total').textContent = upperSubtotal + bonus;
            document.getElementById('grand-total').textContent = getPlayerTotal(displayPlayerIndex);
        }
        
        function updateLeaderboard() {
            if (!state.players) return;
            leaderboard.innerHTML = state.players.map((pId, i) => {
                const name = (i === myPlayerIndex) ? '나' : (gameMode.startsWith('online') ? '상대' : 'AI');
                return `
                <div class="leaderboard-item flex justify-between items-center p-2 rounded ${i === state.currentPlayer ? 'current-player' : ''}">
                    <span class="font-bold text-lg">${name} (P${i+1})</span>
                    <span class="text-lg font-semibold">${getPlayerTotal(i)}</span>
                </div>
            `}).join('');
        }
        
        async function rollDice() {
            if (state.currentPlayer !== myPlayerIndex || state.rollsLeft <= 0 || state.status !== 'active') return;
            const newDice = state.dice.map((d, i) => state.kept[i] ? d : Math.floor(Math.random() * 6) + 1);
            
            const newState = {
                dice: newDice,
                rollsLeft: state.rollsLeft - 1,
                isTurnStarted: true,
                message: state.rollsLeft - 1 > 0 ? "유지할 주사위를 선택하세요." : "점수를 기록할 항목을 선택하세요."
            };
            
            if (gameMode.startsWith('online')) {
                await updateDoc(doc(db, "games", gameId), newState);
            } else {
                updateGameState(newState);
            }
        }

        async function toggleKeep(index) {
            if (state.currentPlayer !== myPlayerIndex || !state.isTurnStarted || state.rollsLeft === 3 || state.status !== 'active') return;
            const newKept = [...state.kept];
            newKept[index] = !newKept[index];
            
            if (gameMode.startsWith('online')) {
                await updateDoc(doc(db, "games", gameId), { kept: newKept });
            } else {
                updateGameState({ kept: newKept });
            }
        }

        async function selectScore(e) {
            const row = e.target.closest('.score-row');
            if (!row || state.currentPlayer !== myPlayerIndex || !state.isTurnStarted || row.classList.contains('scored') || state.status !== 'active') return;
            
            if (scoreMessageTimeout) clearTimeout(scoreMessageTimeout);
            
            // 1. Get score and ID
            const id = row.dataset.id;
            const potential = calculateScores(state.dice);
            const scoredValue = potential[id];
            
            await scoreAndEndHumanTurn(id, scoredValue);
        }
        
        async function scoreAndEndHumanTurn(id, score) {
            const newScores = [...state.scores];
            newScores[myPlayerIndex][id] = score;
            const scoreName = SCORE_CATEGORIES.upper[id] || SCORE_CATEGORIES.lower[id];
            const playerName = (myPlayerIndex === 0) ? "Player 1" : "Player 2";
            const scoreMessage = `${playerName} (당신)이 ${scoreName}에 ${score}점을 기록했습니다.`;

            // 2. Calculate next turn
            let nextPlayer = state.currentPlayer + 1;
            let nextRound = state.round;
            if (nextPlayer >= state.players.length) {
                nextPlayer = 0;
                nextRound++;
            }

            // 3. Update doc/state with score and message (disables UI)
            const scoreUpdateState = {
                scores: newScores,
                message: scoreMessage,
                isTurnStarted: false, // Prevents further action
                rollsLeft: 0 // Prevents further rolls
            };

            // 메시지 영역에 점수 메시지 즉시 표시
            document.getElementById('message-area').textContent = scoreMessage;

            if (gameMode.startsWith('online')) {
                await updateDoc(doc(db, "games", gameId), scoreUpdateState);
            } else {
                updateGameState(scoreUpdateState);
            }
            
            // 4. Wait for 1.5 seconds
            scoreMessageTimeout = setTimeout(async () => {
                scoreMessageTimeout = null; // 타이머 클리어
                if(state.status === 'finished') return; // 이미 게임 종료됨

                if (nextRound > 13) {
                    await endGame();
                } else {
                    // 5. Update doc/state to change turn
                    const nextTurnState = {
                        currentPlayer: nextPlayer,
                        round: nextRound,
                        rollsLeft: 3,
                        kept: [false, false, false, false, false],
                        isTurnStarted: false,
                        message: `Player ${nextPlayer + 1}의 턴입니다.`
                    };
                    if (gameMode.startsWith('online')) {
                        await updateDoc(doc(db, "games", gameId), nextTurnState);
                    } else {
                        updateGameState(nextTurnState);
                        
                        // *** FIX: AI 턴은 오직 사람 턴이 끝난 직후에만 트리거됩니다. ***
                        if (gameMode === 'ai' && nextPlayer === 1 && !aiTurnTimeout) {
                            aiTurnTimeout = setTimeout(runAITurn, 1000); // 1초 후 AI 턴 시작
                        }
                    }
                }
            }, 1500); // 1.5초 딜레이
        }

        
        async function endGame(isFinishedByOpponent = false) {
            if (aiTurnTimeout) { clearTimeout(aiTurnTimeout); aiTurnTimeout = null; }
            if (scoreMessageTimeout) { clearTimeout(scoreMessageTimeout); scoreMessageTimeout = null; }
            
            // Ensure state.players is valid before mapping
            if (!state.players || state.players.length === 0) {
                 console.warn("EndGame called with no players in state.");
                 init(); // Go to init if state is corrupt
                 return;
            }

            const finalTotals = state.players.map((pId, i) => ({ 
                player: i + 1, 
                name: (i === myPlayerIndex) ? '나' : (gameMode.startsWith('online') ? '상대' : 'AI'), 
                score: getPlayerTotal(i) 
            })).sort((a, b) => b.score - a.score);
            
            document.getElementById('final-leaderboard').innerHTML = finalTotals.map(p => `<p>${p.name} (Player ${p.player}): <span class="font-bold text-xl">${p.score}</span>점</p>`).join('');

            const winnerMessageEl = document.getElementById('winner-message');
            if (finalTotals.length > 1 && finalTotals[0].score === finalTotals[1]?.score) {
                winnerMessageEl.textContent = '무승부입니다!';
            } else if (finalTotals.length > 0) {
                winnerMessageEl.textContent = `${finalTotals[0].name} (Player ${finalTotals[0].player})의 승리입니다!`;
            } else {
                 winnerMessageEl.textContent = '게임이 종료되었습니다.';
            }
            
            if(gameMode.startsWith('online') && !isFinishedByOpponent) {
                await updateDoc(doc(db, "games", gameId), { status: 'finished' });
            } else if (gameMode === 'ai' && state.status !== 'finished') { // AI 모드일 때도 state 업데이트
                updateGameState({ status: 'finished' });
            }
            gameOverModal.classList.remove('hidden');
        }

        function getDieHTML(value, index, isKept) { 
            const keptClass = isKept ? 'kept' : '';
            const dots = [[],['<circle cx="50" cy="50" r="8"/>'],['<circle cx="25" cy="25" r="8"/>','<circle cx="75" cy="75" r="8"/>'],['<circle cx="25" cy="25" r="8"/>','<circle cx="50" cy="50" r="8"/>','<circle cx="75" cy="75" r="8"/>'],['<circle cx="25" cy="25" r="8"/>','<circle cx="75" cy="25" r="8"/>','<circle cx="25" cy="75" r="8"/>','<circle cx="75" cy="75" r="8"/>'],['<circle cx="25" cy="25" r="8"/>','<circle cx="75" cy="25" r="8"/>','<circle cx="50" cy="50" r="8"/>','<circle cx="25" cy="75" r="8"/>','<circle cx="75" cy="75" r="8"/>'],['<circle cx="25" cy="25" r="8"/>','<circle cx="75" cy="25" r="8"/>','<circle cx="25" cy="50" r="8"/>','<circle cx="75" cy="50" r="8"/>','<circle cx="25" cy="75" r="8"/>','<circle cx="75" cy="75" r="8"/>']];
            return `<div class="die w-14 h-14 sm:w-20 sm:h-20 bg-white rounded-lg shadow-md border-4 border-gray-200 flex items-center justify-center ${keptClass}" data-index="${index}"><svg viewBox="0 0 100 100" class="w-full h-full fill-current text-gray-800">${dots[value].join('')}</svg></div>`;
        }
        function calculateScores(dice) {
            const counts = new Array(7).fill(0); let sum = 0;
            dice.forEach(d => { counts[d]++; sum += d; });
            const potential = {};
            Object.keys(SCORE_CATEGORIES.upper).forEach((id, i) => { potential[id] = counts[i+1] * (i+1); });
            const countsValues = Object.values(counts);
            potential.threeOfAKind = countsValues.some(c => c >= 3) ? sum : 0;
            potential.fourOfAKind = countsValues.some(c => c >= 4) ? sum : 0;
            potential.fullHouse = countsValues.includes(3) && countsValues.includes(2) ? 25 : 0;
            potential.yatzy = countsValues.some(c => c >= 5) ? 50 : 0;
            potential.chance = sum;
            const uniqueDiceStr = Array.from(new Set(dice)).sort().join('');
            potential.smallStraight = /1234|2345|3456/.test(uniqueDiceStr) ? 30 : 0;
            potential.largeStraight = /12345|23456/.test(uniqueDiceStr) ? 40 : 0;
            return potential;
        }
        function getPlayerTotal(playerIndex) {
            if(!state.scores || !state.scores[playerIndex]) return 0;
            const playerScores = state.scores[playerIndex]; let upperSubtotal = 0;
            Object.keys(SCORE_CATEGORIES.upper).forEach(id => { if (playerScores[id] !== null) upperSubtotal += playerScores[id]; });
            const bonus = upperSubtotal >= 63 ? 35 : 0; let total = upperSubtotal + bonus;
            Object.keys(SCORE_CATEGORIES.lower).forEach(id => { if (playerScores[id] !== null) total += playerScores[id]; });
            return total;
        }
        
        // --- AI LOGIC ---
        async function runAITurn() {
            // ... (AI 로직은 이전과 동일하게 유지) ...
            
            if (aiTurnTimeout) { clearTimeout(aiTurnTimeout); aiTurnTimeout = null; }
            if (scoreMessageTimeout) { clearTimeout(scoreMessageTimeout); scoreMessageTimeout = null; }
            const aiPlayerScores = state.scores[1];
            if (state.rollsLeft === 3) {
                const newDice = state.dice.map(() => Math.floor(Math.random() * 6) + 1);
                updateGameState({ dice: newDice, kept: [false,false,false,false,false], rollsLeft: 2, isTurnStarted: true, message: "AI가 주사위를 굴립니다..." });
            }
            let potential = calculateScores(state.dice);
            let earlyScore = checkEarlyScore(potential, aiPlayerScores);
            if (earlyScore) {
                return await scoreAndEndAITurn(earlyScore.id, earlyScore.score);
            }
            await new Promise(resolve => setTimeout(resolve, 1500));
            if(state.status === 'finished') return; 
            let bestKeep = aiDecideKeep(state.dice, aiPlayerScores);
            let newDice = state.dice.map((d, i) => bestKeep.kept[i] ? d : Math.floor(Math.random() * 6) + 1);
            updateGameState({ dice: newDice, kept: bestKeep.kept, rollsLeft: 1, message: `AI가 ${bestKeep.reason} (을)를 위해 주사위를 굴립니다...` });
            potential = calculateScores(state.dice);
            earlyScore = checkEarlyScore(potential, aiPlayerScores);
            if (earlyScore) {
                return await scoreAndEndAITurn(earlyScore.id, earlyScore.score);
            }
            await new Promise(resolve => setTimeout(resolve, 1500));
            if(state.status === 'finished') return; 
            bestKeep = aiDecideKeep(state.dice, aiPlayerScores);
            newDice = state.dice.map((d, i) => bestKeep.kept[i] ? d : Math.floor(Math.random() * 6) + 1);
            updateGameState({ dice: newDice, kept: bestKeep.kept, rollsLeft: 0, message: `AI가 ${bestKeep.reason} (을)를 위해 마지막으로 굴립니다...` });
            await new Promise(resolve => setTimeout(resolve, 1500));
            if(state.status === 'finished') return;
            potential = calculateScores(state.dice);
            const bestChoice = aiBestChoice(aiPlayerScores, potential);
            return await scoreAndEndAITurn(bestChoice.id, bestChoice.score);
        }
        async function scoreAndEndAITurn(id, score) {
            const newScores = [...state.scores];
            newScores[1][id] = score; // AI는 player 1
            const scoreName = SCORE_CATEGORIES.upper[id] || SCORE_CATEGORIES.lower[id];
            const scoreMessage = `AI (Player 2)가 ${scoreName}에 ${score}점을 기록했습니다.`;
            let nextPlayer = 0; // 0 (Human)
            let nextRound = state.round; 
            if (state.currentPlayer === 1) {
                nextRound = state.round + 1;
            }
            updateGameState({
                scores: newScores,
                message: scoreMessage,
                isTurnStarted: false,
                rollsLeft: 0
            });
            document.getElementById('message-area').textContent = scoreMessage;
            scoreMessageTimeout = setTimeout(async () => {
                scoreMessageTimeout = null; 
                if(state.status === 'finished') return;
                if (nextRound > 13) {
                    await endGame();
                } else {
                    updateGameState({
                        currentPlayer: nextPlayer,
                        round: nextRound,
                        rollsLeft: 3,
                        kept: [false, false, false, false, false],
                        isTurnStarted: false,
                        message: `Player ${nextPlayer + 1} (당신)의 턴입니다.`
                    });
                }
            }, 1500);
        }
        function checkEarlyScore(potential, scores) {
            if (scores.yatzy === null && potential.yatzy > 0) return { id: 'yatzy', score: potential.yatzy };
            if (scores.largeStraight === null && potential.largeStraight > 0) return { id: 'largeStraight', score: potential.largeStraight };
            if (scores.fullHouse === null && potential.fullHouse > 0) return { id: 'fullHouse', score: potential.fullHouse };
            return null;
        }
        function aiDecideKeep(dice, scores) {
            const counts = new Array(7).fill(0);
            dice.forEach(d => counts[d]++);
            for (let i = 6; i >= 1; i--) {
                if (counts[i] >= 4 && scores.yatzy === null) return { kept: dice.map(d => d === i), reason: 'Yatzy' };
                if (counts[i] >= 4 && scores.fourOfAKind === null) return { kept: dice.map(d => d === i), reason: '4 of a Kind' };
            }
            if (counts.includes(3) && counts.includes(2) && scores.fullHouse === null) return { kept: [true,true,true,true,true], reason: 'Full House' };
            for (let i = 6; i >= 1; i--) {
                if (counts[i] === 3) return { kept: dice.map(d => d === i), reason: '3 of a Kind' };
            }
            const uniqueSorted = Array.from(new Set(dice)).sort().join('');
            if (/12345|23456/.test(uniqueSorted) && scores.largeStraight === null) return { kept: [true,true,true,true,true], reason: 'Large Straight' };
            if (/1234|2345|3456/.test(uniqueSorted) && scores.smallStraight === null) {
                let straightToKeep = [1,2,3,4];
                if (/2345/.test(uniqueSorted)) straightToKeep = [2,3,4,5];
                if (/3456/.test(uniqueSorted)) straightToKeep = [3,4,5,6];
                return { kept: dice.map(d => straightToKeep.includes(d)), reason: 'Small Straight' };
            }
            const upperIds = ['sixes', 'fives', 'fours', 'threes', 'twos', 'aces'];
            for (let i = 6; i >= 1; i--) {
                const id = upperIds[6-i]; 
                if (scores[id] === null && counts[i] > 0) {
                    return { kept: dice.map(d => d === i), reason: `${i}` };
                }
            }
             for (let i = 6; i >= 1; i--) {
                if (counts[i] === 2) return { kept: dice.map(d => d === i), reason: 'Pair' };
            }
            const maxDie = Math.max(...dice);
            return { kept: dice.map(d => d === maxDie), reason: 'Highest Die' };
        }
        function aiBestChoice(scores, potential) {
            let bestId = 'chance';
            let maxScore = -1;
            const sortedPotential = Object.entries(potential).sort(([,a],[,b]) => b-a);
            for (const [id, score] of sortedPotential) {
                if (scores[id] === null) { 
                    if (score > maxScore) {
                        maxScore = score;
                        bestId = id;
                    }
                }
            }
            if (maxScore <= 0) {
                const upperIds = ['aces', 'twos', 'threes', 'fours', 'fives', 'sixes'];
                for (const id of upperIds) {
                    if (scores[id] === null) {
                        return { id: id, score: potential[id] };
                    }
                }
                const lowerIds = ['yatzy', 'largeStraight', 'smallStraight', 'fullHouse', 'fourOfAKind', 'threeOfAKind', 'chance'];
                for (const id of lowerIds) {
                     if (scores[id] === null) {
                         return { id: id, score: potential[id] };
                     }
                }
            }
            return { id: bestId, score: maxScore };
        }
        // --- END AI LOGIC ---

        // Main Menu Listeners
        findMatchBtn.addEventListener('click', findMatch);
        startAiBtn.addEventListener('click', startAiGame);
        friendMatchBtn.addEventListener('click', showFriendMenu);
        cancelMatchBtn.addEventListener('click', cancelMatch); // For random matching
        
        // Friend Menu Listeners
        backToMainMenuBtn.addEventListener('click', init);
        createRoomBtn.addEventListener('click', createRoom);
        joinRoomBtn.addEventListener('click', joinRoomWithCode);
        
        // Lobby Listeners (New)
        startGameBtn.addEventListener('click', startGame);
        cancelRoomBtn.addEventListener('click', cancelRoom); // Host: Deletes room
        leaveLobbyBtn.addEventListener('click', leaveLobby); // Guest: Leaves room
        lobbyPlayerList.addEventListener('click', (e) => {
            if (e.target.classList.contains('kick-btn')) {
                const guestId = e.target.dataset.kickId;
                if (guestId) {
                    kickPlayer(guestId);
                }
            }
        });
        lobbyCopyCode.addEventListener('click', () => {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(gameId).then(() => {
                    lobbyCopyCode.textContent = "[복사 완료!]";
                    setTimeout(() => lobbyCopyCode.textContent = "[코드 복사]", 2000);
                });
            } else {
                // Fallback for non-secure contexts
                alert("코드가 복사되었습니다: " + gameId);
            }
        });


        // Game Listeners
        rollButton.addEventListener('click', rollDice);
        diceContainer.addEventListener('click', e => {
            const dieEl = e.target.closest('.die');
            if (dieEl) toggleKeep(parseInt(dieEl.dataset.index));
        });
        
        leaveGameButton.addEventListener('click', async () => {
            if (gameMode.startsWith('online') && gameId) {
                try {
                    // Update status to 'finished' instead of deleting, so opponent sees "left" message
                    await updateDoc(doc(db, "games", gameId), { status: 'finished', message: '상대방이 게임을 떠났습니다.' });
                } catch(e) {
                    console.error("Error leaving game doc:", e);
                }
            }
            init();
        });
        modalNewGameButton.addEventListener('click', init);
        
        // Rules Modal Listeners
        function showRules() { gameRulesModal.classList.remove('hidden'); }
        function hideRules() { gameRulesModal.classList.add('hidden'); }

        showRulesBtnSetup.addEventListener('click', showRules);
        showRulesBtnGame.addEventListener('click', showRules);
        closeRulesBtn.addEventListener('click', hideRules);
        closeRulesBtnBottom.addEventListener('click', hideRules);
        gameRulesModal.addEventListener('click', (e) => {
            if (e.target === gameRulesModal) { // Click on the background overlay
                hideRules();
            }
        });
        
        createScoreboardHTML();
        init();

        function createScoreboardHTML() {
            let upperHTML = '', lowerHTML = '';
            for (const [id, name] of Object.entries(SCORE_CATEGORIES.upper)) {
                upperHTML += `<tr class="score-row" data-id="${id}"><td>${name}</td><td class="score text-right font-semibold"></td></tr>`;
            }
            for (const [id, name] of Object.entries(SCORE_CATEGORIES.lower)) {
                lowerHTML += `<tr class="score-row" data-id="${id}"><td>${name}</td><td class="score text-right font-semibold"></td></tr>`;
            }
            document.getElementById('upper-section-body').innerHTML = upperHTML;
            document.getElementById('lower-section-body').innerHTML = lowerHTML;
            document.querySelectorAll('#game-screen .score-row').forEach(row => row.addEventListener('click', selectScore));
        }
    } catch (error) {
        console.error("Firebase 초기화 오류:", error);
        document.body.innerHTML = `<div class="p-4 text-red-700 bg-red-100 rounded-lg">Firebase 설정에 오류가 발생했습니다. 프로젝트 ID가 고유한지, API 키가 올른지 확인해주세요. 자세한 내용은 콘솔을 확인하세요.</div>`;
    }
</script>

</body>
</html>

